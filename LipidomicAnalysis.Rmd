---
title: "The Hitchhikerâ€™s Guide to untargeted lipidomics analysis: Practical guidelines"
author: "D. Smirnov, P. Mazin, M. Osetrova, E. Stekolshchikova, E. Khrameeva"
date: "8/18/2021"
output: 
  github_document:
    pandoc_args: "--webtex"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Here we present step-by-step guide to bioinformatic analysis of untargeted LS-MS lipidomic data. This manual reproduces the key steps described in the manuscript:

* Data importing

* Lipid signal quantification (peak peaking, peak alignment, peak grouping and abundance quantification)

* Filtering and normalization

* Visualization


## Package import
Loading the packages required for analysis
```{r, results='hide', message=FALSE, warning=FALSE}
library(xcms)
library(ggplot2)
library(DT)
library(IPO)
library(mixOmics)
library(dplyr)
library(missForest)
library(reshape2)
library(gridExtra)
```


## Data import
We will demonstrate the key concepts of LC-MS untargeted lipidomic analysis on the example of human and macaque lipidomic profiles from Dorsolateral Prefrontal Cortex. 
Raw MS files from this project converted into the .mzXML format can be downloaded into the current directory using the following code:
```{r}
#url <- "http://arcuda.skoltech.ru/~d.smirnov/sampledata.tar.gz"
#download.file(url, destfile = 'sampledata.tar.gz')
#untar('sampledata.tar.gz')
```

For convenience, raw MS files located in the `sampledata/` folder are organized into two subfolders according to the species (2 files per species + blank measurements). The code below will create a table with sample metadata
```{r}
mzfiles <- list.files('sampledata/', recursive = TRUE, full.names = TRUE, pattern = '.mzXML')
group <- unlist(lapply(strsplit(mzfiles,"/"), function (x) x[[3]]))
pd <- data.frame(sample_name = sub(basename(mzfiles), pattern = ".mzXML", replacement = "", fixed = TRUE), 
                 sample_group = group, 
                 stringsAsFactors = FALSE)

knitr::kable(pd)
```

Now .mzXML files can be imported into `MSnExp` object via `readMSData` function
```{r}
raw_data <- readMSData(files = mzfiles, 
                       pdata = new("NAnnotatedDataFrame", pd), 
                       mode = "onDisk", 
                       msLevel = 1, 
                       verbose = T, 
                       centroided = T)
```


## Peak picking
Feature detection `CentWave` algorithm based on continuous wavelet transformation allows to distinguish lipid peaks from background noise. To perform peak calling we need to set up CentWave parameters first
```{r}
cwp <- CentWaveParam(peakwidth = c(9.5, 36),
                     ppm = 11.5,
                     noise = 0, 
                     snthresh = 10, 
                     mzdiff = -0.001, 
                     prefilter = c(3, 100), 
                     mzCenterFun = "wMean", 
                     integrate = 1, 
                     fitgauss = FALSE)
```
It's highly recommended to specify `peakwidth` (minimum and maximum MS peak width in RT dimension) and `ppm`(width of region of interest  in the m/z dimension) parameters based on ion chromatograms for internal standards. 

Once the parameters are set one can proceed to chromatographic peak detection using `findChromPeaks` function.
```{r, message=FALSE}
xset <- findChromPeaks(raw_data, param = cwp)
```

## Peak alignment
Peak alignment procedure aims to eliminate retention times shifts between identified chromatographic peaks from samples. We will use OBI-warp algorithm implemented within `xcms` package to match peaks between MS runs.
```{r}
arp <- ObiwarpParam(distFun = "cor_opt", 
                    binSize = 1, 
                    response = 1, 
                    gapInit = 0.32, 
                    gapExtend = 2.688, 
                    factorDiag = 2, 
                    factorGap = 1,
                    localAlignment = FALSE)

xset <- adjustRtime(xset, param = arp)
```
`ObiwarpParam` function creates an object with parameters for the alignment and `adjustRtime` performs the peak matching.


An example of peaks before and after RT shift correction is shown below
```{r, fig.width = 7, fig.height= 3.5}
group_colors <- c("black", "red", "forestgreen")
names(group_colors) <- unique(xset$sample_group)

par(mfrow=c(1,2),las=1)
chr <- chromatogram(xset, rt = c(405, 435), mz = c(797.58, 797.63), aggregationFun = "max", adjustedRtime = F)
chr.adj <- chromatogram(xset, rt = c(405, 435), mz = c(797.58, 797.63), aggregationFun = "max", adjustedRtime = T)
plot(chr, peakType = "none", col=group_colors[xset$sample_group], main = "Before alignment")
legend(426, 32000, legend=c("Blank", "Human", "Macaque"), col=group_colors, lty=1:1, cex=0.45)
plot(chr.adj, peakType = "none", col=group_colors[xset$sample_group], main = "After alignment")
legend(426, 32000, legend=c("Blank", "Human", "Macaque"), col=group_colors, lty=1:1, cex=0.45)
```

## Peak grouping
Once retention time correction is done one can proceed to the correspondence analysis of aligned peaks. The general idea of peak grouping is to identify peaks from the same ion across samples and group them together to form a lipid feature. In order to do this analysis, we will use Peak density method that accessible in `xcms` via `groupChromPeaks` function. 
`PeakDensityParam` object contains grouping settings and is used as input for `groupChromPeaks`.

```{r}
pdp <- PeakDensityParam(sampleGroups = xset$sample_group, 
                        bw = 0.879999999999999, 
                        binSize = 0.02412, 
                        minFraction = 0.000001, 
                        minSamples = 1, 
                        maxFeatures = 50)

xset <- groupChromPeaks(xset, param = pdp)
```


## Selection of parameters for peak picking, alignment, and grouping
For simplicity and saving time, in the code sections above we provided parameters optimized for untargeted lipidome LC-MS measurements on a Reversed-Phase Bridged Ethyl Hybrid (BEH) C8 column reverse coupled to a Vanguard precolumn, using a Waters Acquity UPLC system and a heated electrospray ionization source in combination with a Bruker Impact II QTOF (quadrupole-Time-of-Flight) mass spectrometer. To customize the parameters for a particular LS-MS experiment we recommend optimizing them via `IPO` package. 

Please note that optimizing peak calling parameters with `optimizeXcmsSet` function is a quite computationally intensive operation. It may take hours or even days (depending on the number of samples) before the optimization process ends!

To perform the optimization just uncomment the code below. It will return the R script with optimized processing parameters.

```{r}
#peakpickingParameters <- getDefaultXcmsSetStartingParams('centWave')
#peakpickingParameters$min_peakwidth = c(0,10)
#peakpickingParameters$max_peakwidth = c(10,30)
#peakpickingParameters$ppm = c(0,10)
```

```{r}
#resultPeakpicking <- optimizeXcmsSet(files = mzfiles, 
#                                     params = peakpickingParameters, 
#                                     nSlaves = 0, 
#                                     subdir = NULL)

#optimizedXcmsSetObject <- resultPeakpicking$best_settings$xset

#retcorGroupParameters <- getDefaultRetGroupStartingParams()
#resultRetcorGroup <- optimizeRetGroup(xset = optimizedXcmsSetObject, 
#                                      params = retcorGroupParameters,
#                                      nSlaves = 0,
#                                      subdir = NULL)

#writeRScript(resultPeakpicking$best_settings$parameters, 
#             resultRetcorGroup$best_settings, 1)
```

## Imputation of missing values
Unfortunately, peak peaking algorithm may produces a sufficient numbers of NAs for those samples in which it wasn't able to identify MS peaks. We will try to impute missing chromatographic peaks within samples using `fillChromPeaks` function.
```{r}
xset <- fillChromPeaks(xset)
```
Please note that `fillChromPeaks` can not impute all the gaps in MS data. The remaining missing values will be further removed/imputed in the section "Filtering of peaks" below.


## Data export
Now we can extract feature matrix from `xset` object
```{r, message=FALSE}
pks <- chromPeaks(xset)
grs <- featureDefinitions(xset)
mtx <- featureValues(xset, method="maxint", value="into", filled=T) 

knitr::kable(head(mtx))
```

Change the column names of `mtx` matrix
```{r}
colnames(mtx) <- unlist(strsplit(colnames(mtx), split = '.mzXML'))
```

To correctly normalize abundance matrix `mtx` further we will need the information about internal standards used in the experiment. The code below reads the example table containing TG(15:0-18:1-d7-15:0) standard description and extracts RT and m/z values. 
```{r}
standards <- read.csv("TG_standard.csv", header=T)
std1.mz <- (standards[c(1),]$mzmin + standards[c(1),]$mzmax)/2
std1.rtmin <- standards[c(1),]$rtmin 
std1.rtmax <- standards[c(1),]$rtmax

std2.mz <- (standards[c(2),]$mzmin + standards[c(2),]$mzmax)/2
std2.rtmin <- standards[c(2),]$rtmin 
std2.rtmax <- standards[c(2),]$rtmax

knitr::kable(head(standards))
```
Using the obtained RT and m/z values of standard, the corresponding peaks can be retrieved from the data
```{r}
eps <- 0.05
peak1 <- grs[grs$mzmed < std1.mz+eps & grs$mzmed > std1.mz-eps & grs$rtmed < std1.rtmax & grs$rtmed > std1.rtmin, ]
peak2 <- grs[grs$mzmed < std2.mz+eps & grs$mzmed > std2.mz-eps & grs$rtmed < std2.rtmax & grs$rtmed > std2.rtmin, ]

std.peaks <- c(rownames(peak1), rownames(peak2))
std.peaks
```

Finally, compute the median abundances of peaks found within each sample. Those will come in handy for normalization procedure.
```{r}
div <- apply(mtx[std.peaks, c(2:5)], 2, function (x) median(x,na.rm=T))
```

## Annotation
Annotation is arguably the most tricky part of untargeted LS-MS analysis. Here we present a method to create annotation for lipid features obtained in the previous steps.
```{r, message=FALSE}
source("src/rt-mz.annotator.R")
```

Prepare the reduced version of `grs` table with a new column consisting of merged mz and rt values
```{r}
grs <- as.data.frame(grs)
grs <- grs[rownames(mtx), ]
grs.short <- dplyr::select(grs, mzmed, rtmed)
grs.short$id <- paste(round(grs.short$mzmed, 3), round(grs.short$rtmed, 3), sep = '_')
grs.short <- grs.short[,c(3,1,2)]
colnames(grs.short) <- c('id', 'mz', 'rt')
knitr::kable(head(grs.short))
```
`annotateByMass` function annotates lipid features by matching their exact mass against m/z values of existing lipids from LIPID MAPS database. Adducts can be defined by `ions` parameter, by default the function uses H, Na, NH4,K,NH4 + acetonitrile. Default ppm threshold in `annotateByMass` is 100, but it also can be changed with `ppm` parameter.

```{r, message=FALSE}
ann <- annotateByMass(grs.short, db = LMDB)
dim(ann)
```

The function yields a table containing LM ID of annotated feature along with formula, systematic name, corresponding ppm/ppmd and delta values.
```{r}
grs.annotated <- filter(grs.short, id %in% unique(ann$id))
grs.annotated <- tibble::rownames_to_column(grs.annotated, "xcmsID")
grs.annotated <- full_join(grs.annotated[,c(1,2)], ann, by=c("id"="id"))
knitr::kable(head(grs.annotated))
```
Keep annotated features only
```{r}
mtx <- mtx[unique(grs.annotated$xcmsID),]
```

Also one can try to perform annotation for specific lipid class only. We will illustrate such approach using a custom TAG generator that creates a table of triacylglycerols (TAG_10:0	- TAG_70:8) with corresponding lipid formula and exact masses.

```{r}
tags = generateTGL(10:70,0:8) # the generator is quite simple, some tags it mage are meaningless (like 10:8)
electron.mass = 0.00054858
knitr::kable(head(tags))
```

We will use the same `annotateByMass` function as a before, but with previously generated TAG table instead of full LIPIDMAPS database.
```{r}
ann2 = annotateByMass(grs.short,
                      tags,
                      ions = c(NH4=calcExactMass('NH4')-electron.mass),
                      ppm=10)

knitr::kable(head(ann2))
```

## Filtering of peaks
We will perform feature filtering based on blank samples to retain all features for which the median concentration ratio between biological samples and blank samples is greater than 2.
```{r, message=FALSE}
med.MS <- apply(mtx, 1, function(x) log10(median(x[grep("MS",colnames(mtx),perl=T)], na.rm=T)))
med.blank <- apply(mtx, 1, function(x) log10(median(x[grep("Blank",colnames(mtx))], na.rm=T)))
filter.blank <- (med.MS - med.blank) > log10(2)
filter.blank[filter.blank==T] <- NA
filter.blank[is.na(filter.blank)] <- T
mtx <- mtx[filter.blank, c(2:5)]
```

The proportion of filtered features can be visualized using a mean-difference plot:
```{r, message=FALSE}
plot((med.MS+med.blank)/2, 
     med.MS-med.blank, 
     pch=21, las=1, bg="gray",  
     col="dimgray", cex=1.2, lwd=0.4, xlab = "Sample Intensity", ylab = "Sample - Blank")

points((med.MS[filter.blank]+med.blank[filter.blank])/2,
       med.MS[filter.blank]-med.blank[filter.blank],
       pch=21, bg="#B20F25", col="dimgray", cex=1.2, lwd=0.4)

abline(h=log10(2),col="#B20F25")
```


The code below removes all features that possess more than 30% of NA across samples.
```{r, message=FALSE}
th <- 0.3
peaks.nas <- apply(mtx, 1, function (x) sum(is.na(x)))
mtx <- mtx[(peaks.nas/ncol(mtx)) < th, ]
```

To impute missing values not filled by `fillChromPeaks` and not removed by filtering we will use an implementation of random forest algorithm from `MissForest` package.
```{r, message=FALSE}
mtx.imp <- missForest(mtx)
mtx <- mtx.imp$ximp
```

## Normalization
In order to make samples comparable to each other we will utilize sample-specific normalization by wet weight and internal standards.

Load the matrix of wet weights for our samples
```{r}
wetw <- as.matrix(read.csv("POS.WETWEIGHT.csv", header=F, row.names=1))
wetw <- log10(wetw)
knitr::kable(wetw)
```

Perform the normalization
```{r}
wetw <- wetw[colnames(mtx), ]
mtx <- log10(mtx)
wetw.mean <- log10(mean(wetw))
div.mean <- log10(mean(div))
mtx.normalized <- t(apply(mtx, 1, function (x) x-log10(wetw)-log10(div)+wetw.mean+div.mean))
```

## Downstream analysis
Processed matrix with quantified lipid abundances can be used for downstream analysis. We will apply two classical approaches (PCA and PLS-DA) to analyze the sample-specific differences between human and macaque lipid profiles. 

### Principal Component Analysis (PCA)
PCA is multivariate technique that extremely useful for classification purpose. The key idea of the method is to project original matrix of lipid abundances into low dimensional space. To perform dimensionality reduction PCA computes the reduced set of uncorrelated variables named `Principal Components`. For a given matrix $X_{n \times m}$, where features are rows and samples are columns, principal component vectors can be defined by finding eigenvectors of the following sample covariance matrix $S$:

![\begin{align*}
S = \frac{1}{n-1} X^{T} C_n X
\end{align*}
](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Balign%2A%7D%0AS+%3D+%5Cfrac%7B1%7D%7Bn-1%7D+X%5E%7BT%7D+C_n+X%0A%5Cend%7Balign%2A%7D%0A)

where $C_n = I_n - \frac{1}{n}1_{n} 1^{T}_{n}$ is a centering matrix, $I_n$ represents an identity matrix of size $n$. 

To calculate principal components we will use base R function `prcomp`
```{r, message=FALSE}
pca <- prcomp(t(mtx.normalized), center = TRUE, scale. = TRUE)
```

To visualize relationships between samples in a new low dimensional space we will plot PC1 and PC2 against each other.

```{r, message=FALSE}
Y <- pd$sample_group[2:5] 
pca.data <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], class = Y)
ggplot(data = pca.data, aes_string(x = "PC1", y = "PC2", color = "class", shape = "class")) + 
    geom_point(size = 5) +
    theme_light()
```

### Partial Least-Squares Discriminant Analysis (PLS-DA)
While both PCA and PLS-DA achieve dimensionality reduction computing the principal components, PLS-DA can be used rather for feature selection than for classification purpose. Mathematically, PLS-DA principal components can be obtained in a similar to PCA manner, as eigenvectors of a matrix of covariances between $X$ and $Y$: 

![\begin{align*}
S = S_{xy} S_{yx} = \frac{1}{n-1} X^{T} C_n Y \times \frac{1}{n-1} Y^{T} C_n X = \frac{1}{(n-1)^2} X^{T} C_n Y Y^{T} C_n X
\end{align*}
](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Balign%2A%7D%0AS+%3D+S_%7Bxy%7D+S_%7Byx%7D+%3D+%5Cfrac%7B1%7D%7Bn-1%7D+X%5E%7BT%7D+C_n+Y+%5Ctimes+%5Cfrac%7B1%7D%7Bn-1%7D+Y%5E%7BT%7D+C_n+X+%3D+%5Cfrac%7B1%7D%7B%28n-1%29%5E2%7D+X%5E%7BT%7D+C_n+Y+Y%5E%7BT%7D+C_n+X%0A%5Cend%7Balign%2A%7D%0A)

where $C_n$ and $n$ represent a centering matrix and a total number of samples, respectively.

We will use the sparse version of the algorithm - sPLS-DA. First of all, matrix of predictors and vector of responses should be defined
```{r, message=FALSE}
X <- t(mtx.normalized)
Y <- as.factor(Y)
```

Tune sPLS-DA parameters using Leave-One-Out cross validation
```{r, message=FALSE}
list.keepX <- seq(1, 100, 2)
tune.splsda <- tune.splsda(X, Y, ncomp = 2, validation = 'loo', folds = 4, 
                           progressBar = FALSE, dist = 'max.dist',
                           test.keepX = list.keepX, nrepeat = 1)
```

Run sPLS-DA with optimized parameters
```{r, message=FALSE}
splsda.model <- splsda(X, Y, ncomp = 2, keepX = tune.splsda$choice.keepX)
plotIndiv(splsda.model, ind.names = FALSE, legend=TRUE, ellipse = TRUE)
```

A vector of feature contributions can be retrieved from the model in the following way
```{r, message=FALSE}
plsda.contributions <- selectVar(splsda.model, comp = 1)$value
```

## Software used
```{r}
sessionInfo()
```


