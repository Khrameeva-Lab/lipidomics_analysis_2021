---
title: "The Hitchhikerâ€™s Guide to untargeted lipidomics analysis: Practical guidelines"
author: "D. Smirnov, P. Mazin, M. Osetrova, E. Stekolshchikova, E. Khrameeva"
date: "8/18/2021"
output: 
  github_document:
    pandoc_args: "--webtex"

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
Here we present step-by-step guide to bioinformatic analysis of untargeted LS-MS lipidomic data. This manual reproduces the key steps described in the manuscript:

* Data importing

* Lipid signal quantification (peak peaking, peak alignment, peak grouping and abundance quantification)

* Filtering and normalization

* Visualization


## Package import
Loading the packages required for analysis
```{r, results='hide', message=FALSE, warning=FALSE}
library(xcms)
library(ggplot2)
library(DT)
library(IPO)
library(mixOmics)
library(dplyr)
library(missForest)
library(reshape2)
library(gridExtra)
```


## Data import
We will demonstrate the key concepts of LC-MS untargeted lipidomic analysis on the example of human fibroblasts dataset (ST001691 study from https://www.metabolomicsworkbench.org/). 
Raw MS files from this project converted into the .mzXML format can be downloaded into the current directory using the following code:
```{r}
#url <- "http://arcuda.skoltech.ru/~d.smirnov/sampledata.tar.gz"
#download.file(url, destfile = 'sampledata.tar.gz')
#untar('sampledata.tar.gz')
```

For convenience, raw MS files located in the `sampledata/` folder are organized into two subfolders according to the treatment groups (two files per group). The code below will create a table with sample metadata
```{r}
mzfiles <- list.files('sampledata/', recursive = TRUE, full.names = TRUE, pattern = '.mzXML')
group <- unlist(lapply(strsplit(mzfiles,"/"), function (x) x[[3]]))
pd <- data.frame(sample_name = sub(basename(mzfiles), pattern = ".mzXML", replacement = "", fixed = TRUE), 
                 sample_group = group, 
                 stringsAsFactors = FALSE)

knitr::kable(pd)
```

Now .mzXML files can be imported into `MSnExp` object via `readMSData` function
```{r}
raw_data <- readMSData(files = mzfiles, 
                       pdata = new("NAnnotatedDataFrame", pd), 
                       mode = "onDisk", 
                       msLevel = 1, 
                       verbose = T, 
                       centroided = T)
```


## Peak picking
Feature detection `CentWave` algorithm based on continuous wavelet transformation allows to distinguish lipid peaks from background noise. To perform peak calling we need to set up CentWave parameters first
```{r}
cwp <- CentWaveParam(peakwidth = c(9.5, 36),
                     ppm = 11.5,
                     noise = 0, 
                     snthresh = 10, 
                     mzdiff = -0.001, 
                     prefilter = c(3, 100), 
                     mzCenterFun = "wMean", 
                     integrate = 1, 
                     fitgauss = FALSE)
```
It's highly recommended to specify `peakwidth` (minimum and maximum MS peak width in RT dimension) and `ppm`(width of region of interest  in the m/z dimension) parameters based on ion chromatograms for internal standards. 

Once the parameters are set one can proceed to chromatographic peak detection using `findChromPeaks` function.
```{r, message=FALSE}
xset <- findChromPeaks(raw_data, param = cwp)
```

## Peak alignment
Peak alignment procedure aims to eliminate retention times shifts between identified chromatographic peaks from samples. We will use OBI-warp algorithm implemented within `xcms` package to match peaks between MS runs.
```{r}
arp <- ObiwarpParam(distFun = "cor_opt", 
                    binSize = 1, 
                    response = 1, 
                    gapInit = 0.32, 
                    gapExtend = 2.688, 
                    factorDiag = 2, 
                    factorGap = 1,
                    localAlignment = FALSE)

xset <- adjustRtime(xset, param = arp)
```
`ObiwarpParam` function creates an object with parameters for the alignment and `adjustRtime` performs the peak matching.

## Peak grouping
Once retention time correction is done one can proceed to the correspondence analysis of aligned peaks. The general idea of peak grouping is to identify peaks from the same ion across samples and group them together to form a lipid feature. In order to do this analysis, we will use Peak density method that accessible in `xcms` via `groupChromPeaks` function. 
`PeakDensityParam` object contains grouping settings and is used as input for `groupChromPeaks`.

```{r}
pdp <- PeakDensityParam(sampleGroups = xset$sample_group, 
                        bw = 0.879999999999999, 
                        binSize = 0.02412, 
                        minFraction = 0.000001, 
                        minSamples = 1, 
                        maxFeatures = 50)

xset <- groupChromPeaks(xset, param = pdp)
```


## Selection of parameters for peak picking, alignment, and grouping
For simplicity and saving time, in the code sections above we provided parameters optimized for untargeted lipidome LC-MS measurements on a Reversed-Phase Bridged Ethyl Hybrid (BEH) C8 column reverse coupled to a Vanguard precolumn, using a Waters Acquity UPLC system and a heated electrospray ionization source in combination with a Bruker Impact II QTOF (quadrupole-Time-of-Flight) mass spectrometer. To customize the parameters for a particular LS-MS experiment we recommend optimizing them via `IPO` package. 

Please note that optimizing peak calling parameters with `optimizeXcmsSet` function is a quite computationally intensive operation. It may take hours or even days (depending on the number of samples) before the optimization process ends!

```{r}
peakpickingParameters <- getDefaultXcmsSetStartingParams('centWave')
peakpickingParameters$min_peakwidth = c(0,10)
peakpickingParameters$max_peakwidth = c(10,30)
peakpickingParameters$ppm = c(0,10)
```

To perform the optimization just uncomment the code below. It will return the R script with optimized processing parameters.
```{r}
#resultPeakpicking <- optimizeXcmsSet(files = mzfiles, 
#                                     params = peakpickingParameters, 
#                                     nSlaves = 0, 
#                                     subdir = NULL)

#optimizedXcmsSetObject <- resultPeakpicking$best_settings$xset

#retcorGroupParameters <- getDefaultRetGroupStartingParams()
#resultRetcorGroup <- optimizeRetGroup(xset = optimizedXcmsSetObject, 
#                                      params = retcorGroupParameters,
#                                      nSlaves = 0,
#                                      subdir = NULL)

#writeRScript(resultPeakpicking$best_settings$parameters, 
#             resultRetcorGroup$best_settings, 1)
```

## Imputation of missing values
Unfortunately, peak peaking algorithm may produces a sufficient numbers of NAs for those samples in which it wasn't able to identify MS peaks. We will try to impute missing chromatographic peaks within samples using `fillChromPeaks` function.
```{r}
xset <- fillChromPeaks(xset)
```
Please note that `fillChromPeaks` can not impute all the gaps in MS data. The remaining missing values will be further removed/imputed in the section "Filtering of peaks" below.


## Data export
Now we can extract feature matrix from `xset` object
```{r, message=FALSE}
pks <- chromPeaks(xset)
grs <- featureDefinitions(xset)
mtx <- featureValues(xset, method="maxint", value="into", filled=T) 

knitr::kable(head(mtx))
```

## Filtering of peaks
The code below removes all features that possess more than 30% of NA across samples.
```{r, message=FALSE}
th <- 0.3
peaks.nas <- apply(mtx, 1, function (x) sum(is.na(x)))
mtx <- mtx[(peaks.nas/ncol(mtx)) < th, ]
```

To impute missing values not filled by `fillChromPeaks` and not removed by filtering we will use an implementation of random forest algorithm from `MissForest` package.
```{r, message=FALSE}
mtx.imp <- missForest(mtx)
mtx <- mtx.imp$ximp
```

## Annotation

Arguably, annotation is the most tricky part of untargeted LS-MS analysis. Here we present 
```{r, message=FALSE}
source("src/rt-mz.annotator.R")
```

```{r}
grs <- as.data.frame(grs)
grs <- grs[rownames(mtx), ]
grs.short <- dplyr::select(grs, mzmed, rtmed)
grs.short$id <- paste(round(grs.short$mzmed, 3), round(grs.short$rtmed, 3), sep = '_')
grs.short <- grs.short[,c(3,1,2)]
colnames(grs.short) <- c('id', 'mz', 'rt')
knitr::kable(head(grs.short))
```

```{r, message=FALSE}
ann <- annotateByMass(grs.short, db = LMDB)
```

```{r}
knitr::kable(head(ann))
```
```{r}
grs.annotated <- filter(grs.short, id %in% unique(ann$id))
mtx <- mtx[rownames(grs.annotated),]
```

## Normalization
We will use median normalization method to make samples comparable to each other
```{r}
mtx.normalized <- apply(mtx, 2, function(x) x/median(x))
```

```{r}
mtx.normalized <- log10(mtx.normalized+1)
```

```{r}
NormalizationPlot <- function(data, title){
    fill <- "#4271AE"
    line <- "#1F3552"
    data <- melt(data)
    colnames(data) <- c("Variable", "Samples", "Abundance")
    font.size <- 8
    ggplot(data,aes(x = Abundance, y = Samples)) + 
        geom_boxplot(fill = fill, colour = line, alpha = 0.7) + coord_flip() +
        ggtitle(title) + theme_light(base_size = 12) + ylab(NULL)
}
```

```{r}
options(repr.plot.width=15, repr.plot.height=7)
p1 <- NormalizationPlot(log10(mtx), title = 'Before normalization')
p2 <- NormalizationPlot(mtx.normalized, title = 'After normalization')
grid.arrange(p1, p2, nrow = 1)
```

## Downstream analysis
 
### Principal Component Analysis (PCA)
PCA projects original matrix of lipid abundances into low dimensional space. For a given matrix $X_{n \times m}$, where samples are rows and samples are columns, principal component vectors can be defined by finding eigenvectors of the following sample covariance matrix $S$:

![\begin{align*}
S = \frac{1}{n-1} X^{T} C_n X
\end{align*}
](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Balign%2A%7D%0AS+%3D+%5Cfrac%7B1%7D%7Bn-1%7D+X%5E%7BT%7D+C_n+X%0A%5Cend%7Balign%2A%7D%0A)

where $C_n = I_n - \frac{1}{n}1_{n} 1^{T}_{n}$ is a centering matrix, $I_n$ represents an identity matrix of size $n$. 

To calculate principal components we will use base R function `prcomp`
```{r, message=FALSE}
pca <- prcomp(t(mtx.normalized), center = TRUE, scale. = TRUE)
```

To visualize relationships between samples in a new low dimensional space we will plot PC1 and PC2 against each other.

```{r, message=FALSE}
Y <- pd$sample_group 
pca.data <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], class = Y)
ggplot(data = pca.data, aes_string(x = "PC1", y = "PC2", color = "class", shape = "class")) + 
    geom_point(size = 4) +
    theme_light()
```

### Partial Least-Squares Discriminant Analysis (PLS-DA)

Mathematically, PLS-DA principal components can be obtained in a similar to PCA manner, as eigenvectors of a matrix of covariances between $X$ and $Y$: 

![\begin{align*}
S = S_{xy} S_{yx} = \frac{1}{n-1} X^{T} C_n Y \times \frac{1}{n-1} Y^{T} C_n X = \frac{1}{(n-1)^2} X^{T} C_n Y Y^{T} C_n X
\end{align*}
](https://render.githubusercontent.com/render/math?math=%5Cdisplaystyle+%5Cbegin%7Balign%2A%7D%0AS+%3D+S_%7Bxy%7D+S_%7Byx%7D+%3D+%5Cfrac%7B1%7D%7Bn-1%7D+X%5E%7BT%7D+C_n+Y+%5Ctimes+%5Cfrac%7B1%7D%7Bn-1%7D+Y%5E%7BT%7D+C_n+X+%3D+%5Cfrac%7B1%7D%7B%28n-1%29%5E2%7D+X%5E%7BT%7D+C_n+Y+Y%5E%7BT%7D+C_n+X%0A%5Cend%7Balign%2A%7D%0A)

where $C_n$ and $n$ represent a centering matrix and a total number of samples, respectively.

```{r, message=FALSE}
X <- t(na.omit(mtx))
Y <- as.factor(Y)
plsda.model <- plsda(X, Y, ncomp = 2)
plotIndiv(plsda.model, ind.names = FALSE, legend=TRUE, ellipse = TRUE)
```

```{r, message=FALSE}
plsda.contributions <- selectVar(plsda.model, comp = 1)$value
```

## Software used
```{r}
sessionInfo()
```









